/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "tests/tabathae_test.check" instead.
 */

#include <check.h>
#include <limits.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "../s21_decimal.h"
#include "../s21_decimal_functions/s21_decimal_helpers.h"

#define AR_OK 0
#define AR_TOOBIG 1
#define AR_TOOSMALL 2
#define AR_DIVZERO 3

#define COMP_TRUE 1
#define COMP_FALSE 0

#define DECLARE_FOR_SUB                                  \
  s21_decimal_mask a = {.orig = {0}}, b = {.orig = {0}}; \
  s21_decimal_mask result = {.orig = {0}}, expected_result = {.orig = {0}};

#define INIT_ALL_SUB              \
  s21_init_decimal(&a.orig);      \
  s21_init_decimal(&b.orig);      \
  s21_init_decimal(&result.orig); \
  s21_init_decimal(&expected_result.orig);

#define CHECK_SUB_OK                                                     \
  ck_assert_int_eq(AR_OK, s21_sub(a.orig, b.orig, &result.orig));        \
  ck_assert_int_eq(result.mask.scale, expected_result.mask.scale);       \
  ck_assert_int_eq(result.mask.sign, expected_result.mask.sign);         \
  for (int i = 0; i < 4; i++) {                                          \
    ck_assert_int_eq(result.orig.bits[i], expected_result.orig.bits[i]); \
  }                                                                      \
  s21_init_decimal(&result.orig);

#define CHECK_SUB_TOO_BIG \
  ck_assert_int_eq(AR_TOOBIG, s21_sub(a.orig, b.orig, &result.orig));

#define CHECK_SUB_TOO_SMALL \
  ck_assert_int_eq(AR_TOOSMALL, s21_sub(a.orig, b.orig, &result.orig));

#define DECLARE_FOR_COMPARISON \
  s21_decimal_mask a = {.orig = {0}}, b = {.orig = {0}};

#define INIT_ALL_COMPARISON  \
  s21_init_decimal(&a.orig); \
  s21_init_decimal(&b.orig);

#define CHECK_GREATER(VAR) \
  ck_assert_int_eq((VAR), s21_is_greater(a.orig, b.orig));

#define CHECK_GREATER_OR_EQUAL(VAR) \
  ck_assert_int_eq((VAR), s21_is_greater_or_equal(a.orig, b.orig));

#define CHECK_ROUND_OK                                                   \
  ck_assert_int_eq(0, s21_round(a.orig, &result.orig));                  \
  ck_assert_int_eq(result.mask.scale, expected_result.mask.scale);       \
  ck_assert_int_eq(result.mask.sign, expected_result.mask.sign);         \
  for (int i = 0; i < 4; i++) {                                          \
    ck_assert_int_eq(result.orig.bits[i], expected_result.orig.bits[i]); \
  }                                                                      \
  s21_init_decimal(&result.orig);

START_TEST(s21_sub_simple_zero_scale) {
  DECLARE_FOR_SUB

  a.mask.number[0] = 5;
  b.mask.number[0] = 3;
  expected_result.mask.number[0] = 2;
  CHECK_SUB_OK

  b.mask.number[0] = 6;
  expected_result.mask.sign = 1;
  expected_result.mask.number[0] = 1;
  CHECK_SUB_OK

  a.mask.sign = 1;
  b.mask.sign = 1;
  expected_result.mask.sign = 0;
  CHECK_SUB_OK

  INIT_ALL_SUB
  CHECK_SUB_OK

  a.mask.number[0] = UINT32_MAX;
  b.mask.number[0] = 5;
  expected_result.mask.number[0] = UINT32_MAX - 5;
  CHECK_SUB_OK

  a.mask.number[1] = 1;
  b.mask.number[0] = UINT32_MAX;
  expected_result.mask.number[0] = 0;
  expected_result.mask.number[1] = 1;
  CHECK_SUB_OK

  a.mask.number[1] = 3;
  b.mask.number[0] = UINT32_MAX - 1;
  expected_result.mask.number[1] = 3;
  expected_result.mask.number[0] = 1;
  CHECK_SUB_OK

  a.mask.number[1] = UINT32_MAX;
  b.mask.number[0] = 13;
  expected_result.mask.number[1] = UINT32_MAX;
  expected_result.mask.number[0] = UINT32_MAX - 13;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.number[0] = UINT32_MAX - 1001;
  b.mask.number[0] = UINT32_MAX - 100;
  expected_result.mask.sign = 1;
  expected_result.mask.number[0] = 901;
  CHECK_SUB_OK

  a.mask.number[1] = UINT32_MAX;
  a.mask.number[2] = UINT32_MAX;
  b.mask.number[1] = UINT32_MAX;
  b.mask.number[2] = UINT32_MAX;
  CHECK_SUB_OK

  a.mask.number[0] = 1;
  b.mask.number[0] = UINT32_MAX;
  expected_result.mask.number[0] = UINT32_MAX - 1;
  CHECK_SUB_OK

  a.mask.number[2] = 0;
  expected_result.mask.number[2] = UINT32_MAX;
  CHECK_SUB_OK

  a.mask.number[1] = 0;
  expected_result.mask.number[1] = UINT32_MAX;
  CHECK_SUB_OK

  INIT_ALL_SUB

  b.mask.number[0] = UINT32_MAX;
  b.mask.number[1] = UINT32_MAX;
  b.mask.number[2] = UINT32_MAX;
  expected_result.mask.number[0] = UINT32_MAX;
  expected_result.mask.number[1] = UINT32_MAX;
  expected_result.mask.number[2] = UINT32_MAX;
  expected_result.mask.sign = 1;
  CHECK_SUB_OK

  a.mask.number[0] = 11;
  expected_result.mask.number[0] = UINT32_MAX - 11;
  CHECK_SUB_OK

  a.mask.number[1] = 13;
  expected_result.mask.number[1] = UINT32_MAX - 13;
  CHECK_SUB_OK
}
END_TEST

START_TEST(s21_sub_harder_zero_scale) {
  DECLARE_FOR_SUB

  a.mask.number[0] = 0b00011111000000011000101111100110;
  a.mask.number[1] = 0b1;
  b.mask.number[0] = 0b11111010100011110010011100000110;
  b.mask.number[1] = 0b111000010010101;
  expected_result.mask.sign = 1;
  expected_result.mask.number[0] = 0b11011011100011011001101100100000;
  expected_result.mask.number[1] = 0b111000010010100;
  CHECK_SUB_OK

  a.mask.number[0] = 0b11111111111111111111111111110111;
  a.mask.number[1] = 0b11111111111111111111111111111111;
  a.mask.number[2] = 0b1001;
  b.mask.number[0] = 0b11111111111111111111111111111111;
  b.mask.number[1] = 0b11111111111111111111111111111111;
  b.mask.number[2] = 0b111111;
  expected_result.mask.number[0] = 0b00000000000000000000000000001000;
  expected_result.mask.number[1] = 0;
  expected_result.mask.number[2] = 0b110110;
  CHECK_SUB_OK

  b.mask.number[0] = 0b11111100111111100111100111111111;
  b.mask.number[1] = 0b11111111111111100011110111111011;
  b.mask.number[2] = 0b1001;
  expected_result.mask.sign = 0;
  expected_result.mask.number[0] = 0b11000000011000010111111000;
  expected_result.mask.number[1] = 0b11100001000000100;
  expected_result.mask.number[2] = 0;
  CHECK_SUB_OK

  b.mask.number[0] = 0;
  b.mask.number[1] = 0;
  b.mask.number[2] = UINT32_MAX;
  expected_result.mask.sign = 1;
  expected_result.mask.number[0] = 0b1001;
  expected_result.mask.number[1] = 0;
  expected_result.mask.number[2] = 0b11111111111111111111111111110101;
  CHECK_SUB_OK

  b.mask.number[0] = UINT32_MAX;
  b.mask.number[1] = UINT32_MAX;
  b.mask.number[2] = UINT32_MAX - 1;
  expected_result.mask.sign = 1;
  expected_result.mask.number[0] = 0b00000000000000000000000000001000;
  expected_result.mask.number[1] = 0;
  expected_result.mask.number[2] = 0b11111111111111111111111111110101;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.number[0] = 1;
  b.mask.number[0] = 1;
  b.mask.sign = 1;
  expected_result.mask.number[0] = 2;
  CHECK_SUB_OK

  a.mask.number[0] = UINT32_MAX;
  expected_result.mask.number[0] = 0;
  expected_result.mask.number[1] = 1;
  CHECK_SUB_OK

  a.mask.number[1] = UINT32_MAX;
  b.mask.number[0] = 2;
  expected_result.mask.number[0] = 1;
  expected_result.mask.number[1] = 0;
  expected_result.mask.number[2] = 1;
  CHECK_SUB_OK

  a.mask.sign = 1;
  expected_result.mask.number[0] = UINT32_MAX - 2;
  expected_result.mask.number[1] = UINT32_MAX;
  expected_result.mask.number[2] = 0;
  expected_result.mask.sign = 1;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.number[0] = 5;
  a.mask.sign = 1;
  b.mask.number[0] = 6;
  b.mask.sign = 1;
  expected_result.mask.number[0] = 1;
  CHECK_SUB_OK
}
END_TEST

START_TEST(s21_sub_diff_scales) {
  DECLARE_FOR_SUB

  a.mask.scale = 7;
  a.mask.number[0] = 5;
  b.mask.scale = 7;
  b.mask.number[0] = 3;
  expected_result.mask.number[0] = 2;
  expected_result.mask.scale = 7;
  CHECK_SUB_OK

  a.mask.scale = 28;
  a.mask.number[0] = 50;
  b.mask.scale = 27;
  b.mask.number[0] = 3;
  expected_result.mask.number[0] = 20;
  expected_result.mask.scale = 28;
  CHECK_SUB_OK

  a.mask.scale = 20;
  a.mask.number[0] = 500000;
  b.mask.scale = 15;
  b.mask.number[0] = 3;
  expected_result.mask.number[0] = 200000;
  expected_result.mask.scale = 20;
  CHECK_SUB_OK

  a.mask.scale = 18;
  a.mask.number[0] = 1;

  expected_result.mask.number[0] = 2999;
  expected_result.mask.scale = 18;
  expected_result.mask.sign = 1;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.scale = 1;
  a.mask.number[0] = 35;
  b.mask.scale = 2;
  b.mask.number[0] = 450;
  expected_result.mask.number[0] = 100;
  expected_result.mask.scale = 2;
  expected_result.mask.sign = 1;
  CHECK_SUB_OK

  a.mask.scale = 10;
  a.mask.number[0] = 4294967295;
  a.mask.number[1] = 1;
  b.mask.scale = 5;
  b.mask.number[0] = 42949;
  expected_result.mask.number[0] = 67295;
  expected_result.mask.number[1] = 1;
  expected_result.mask.scale = 10;
  expected_result.mask.sign = 0;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.sign = 1;
  a.mask.scale = 7;
  a.mask.number[0] = 1234567;
  b.mask.sign = 1;
  b.mask.scale = 8;
  b.mask.number[0] = 12345678;
  expected_result.mask.number[0] = 8;
  expected_result.mask.scale = 8;
  expected_result.mask.sign = 0;
  CHECK_SUB_OK

  INIT_ALL_SUB

  a.mask.scale = 9;
  a.mask.number[0] = 0b101111101011110000100000000;
  b.mask.scale = 1;
  b.mask.number[0] = 1;
  expected_result.mask.scale = 9;
  CHECK_SUB_OK

  a.mask.scale = 5;
  a.mask.number[0] = 1000000;
  b.mask.scale = 2;
  b.mask.number[0] = 1000;
  expected_result.mask.scale = 5;
  CHECK_SUB_OK
}
END_TEST

START_TEST(s21_sub_overflow) {
  DECLARE_FOR_SUB

  a.mask.number[0] = UINT32_MAX;
  a.mask.number[1] = UINT32_MAX;
  a.mask.number[2] = UINT32_MAX;
  b.mask.sign = 1;
  b.mask.number[0] = 1;
  CHECK_SUB_TOO_BIG

  b.mask.number[0] = UINT32_MAX;
  b.mask.number[1] = UINT32_MAX;
  b.mask.number[2] = UINT32_MAX;
  CHECK_SUB_TOO_BIG

  b.mask.scale = 28;
  CHECK_SUB_TOO_BIG

  b.mask.scale = 1;
  b.mask.number[0] = 6;
  b.mask.number[1] = 0;
  b.mask.number[2] = 0;
  CHECK_SUB_TOO_BIG

  a.mask.sign = 1;
  b.mask.sign = 0;
  CHECK_SUB_TOO_SMALL

  a.mask.sign = 0;
  b.mask.sign = 1;
  b.mask.number[0] = 5;
  CHECK_SUB_TOO_BIG
}
END_TEST

START_TEST(s21_sub_rounding) {
  DECLARE_FOR_SUB

  a.mask.number[0] = UINT32_MAX;
  a.mask.number[1] = UINT32_MAX;
  a.mask.number[2] = UINT32_MAX;
  b.mask.number[0] = 6;
  b.mask.scale = 1;
  expected_result.mask.number[0] = UINT32_MAX - 1;
  expected_result.mask.number[1] = UINT32_MAX;
  expected_result.mask.number[2] = UINT32_MAX;
  CHECK_SUB_OK

  b.mask.number[0] = 5;
  CHECK_SUB_OK

  b.mask.number[0] = 4;
  expected_result.mask.number[0] = UINT32_MAX;
  CHECK_SUB_OK

  a.mask.sign = 1;
  expected_result.mask.sign = 1;
  CHECK_SUB_OK
}
END_TEST

START_TEST(s21_is_greater_simple) {
  DECLARE_FOR_COMPARISON

  a.mask.number[0] = 3;
  b.mask.number[0] = 2;
  CHECK_GREATER(COMP_TRUE)

  a.mask.number[0] = 4;
  b.mask.number[0] = 4;
  CHECK_GREATER(COMP_FALSE)

  a.mask.number[0] = 11;
  b.mask.number[0] = 13;
  CHECK_GREATER(COMP_FALSE)

  b.mask.sign = 1;
  CHECK_GREATER(COMP_TRUE)

  a.mask.sign = 1;
  CHECK_GREATER(COMP_TRUE)

  b.mask.number[0] = 11;
  CHECK_GREATER(COMP_FALSE)

  INIT_ALL_COMPARISON

  a.mask.scale = 2;
  a.mask.number[0] = UINT32_MAX - 10;
  b.mask.scale = 3;
  b.mask.number[0] = UINT32_MAX - 10;
  CHECK_GREATER(COMP_TRUE)

  b.mask.scale = 1;
  CHECK_GREATER(COMP_FALSE)

  b.mask.scale = 2;
  CHECK_GREATER(COMP_FALSE)

  a.mask.scale = 27;
  b.mask.scale = 28;
  CHECK_GREATER(COMP_TRUE)

  a.mask.scale = 1;
  a.mask.number[0] = 101;
  b.mask.scale = 0;
  b.mask.number[0] = 10;
  CHECK_GREATER(COMP_TRUE)

  a.mask.sign = 1;
  a.mask.scale = 28;
  a.mask.number[0] = UINT32_MAX - 10;
  a.mask.number[1] = UINT32_MAX - 3;
  a.mask.number[2] = UINT32_MAX;
  b.mask.sign = 1;
  b.mask.scale = 28;
  b.mask.number[0] = UINT32_MAX - 9;
  b.mask.number[1] = UINT32_MAX - 3;
  b.mask.number[2] = UINT32_MAX;
  CHECK_GREATER(COMP_TRUE)

  b.mask.number[0] = UINT32_MAX - 10;
  CHECK_GREATER(COMP_FALSE)

  b.mask.number[0] = UINT32_MAX - 11;
  CHECK_GREATER(COMP_FALSE)

  INIT_ALL_COMPARISON

  b.mask.sign = 1;
  CHECK_GREATER(COMP_FALSE)
}
END_TEST

START_TEST(s21_is_greater_or_equal_simple) {
  DECLARE_FOR_COMPARISON

  b.mask.sign = 1;
  CHECK_GREATER_OR_EQUAL(COMP_TRUE)

  a.mask.sign = 1;
  a.mask.scale = 2;
  a.mask.number[0] = 110;
  b.mask.scale = 1;
  b.mask.number[0] = 11;
  CHECK_GREATER_OR_EQUAL(COMP_TRUE)

  b.mask.number[0] = 12;
  CHECK_GREATER_OR_EQUAL(COMP_TRUE)

  b.mask.number[0] = 10;
  CHECK_GREATER_OR_EQUAL(COMP_FALSE)

  INIT_ALL_COMPARISON

  a.mask.scale = 8;
  a.mask.number[0] = 13245 * 1000;
  b.mask.scale = 5;
  b.mask.number[0] = 13245;
  CHECK_GREATER_OR_EQUAL(COMP_TRUE)

  b.mask.number[0] += 1;
  CHECK_GREATER_OR_EQUAL(COMP_FALSE);

  a.mask.scale = 28;
  a.mask.number[0] = UINT32_MAX;
  a.mask.number[1] = UINT32_MAX;
  a.mask.number[2] = UINT32_MAX;
  b.mask.scale = 1;
  b.mask.number[0] = 79;
  CHECK_GREATER_OR_EQUAL(COMP_TRUE)

  b.mask.scale = 2;
  b.mask.number[0] = 793;
  CHECK_GREATER_OR_EQUAL(COMP_FALSE)
}
END_TEST

START_TEST(s21_from_int_to_decimal_full) {
  s21_decimal_mask dst = {.orig = {0}};

  for (int src = -49266; src < 51408; src += 2142) {
    s21_from_int_to_decimal(src, &dst.orig);
    ck_assert_int_eq(src < 0, dst.mask.sign);
    ck_assert_int_eq(abs(src), dst.mask.number[0]);
    s21_init_decimal(&dst.orig);
  }
  s21_from_int_to_decimal(INT_MIN + 1, &dst.orig);
  ck_assert_int_eq(1, dst.mask.sign);
  ck_assert_int_eq(INT_MAX, dst.mask.number[0]);
  s21_from_int_to_decimal(INT_MAX, &dst.orig);
  ck_assert_int_eq(INT_MAX, dst.mask.number[0]);
  s21_from_int_to_decimal(INT_MIN, &dst.orig);
  ck_assert_int_eq(1, dst.mask.sign);
  ck_assert_int_eq((unsigned)INT_MAX + 1, dst.mask.number[0]);
}
END_TEST

START_TEST(s21_round_simple) {
  s21_decimal_mask a = {.orig = {0}}, result = {.orig = {0}},
                   expected_result = {.orig = {0}};

  a.mask.scale = 1;
  a.mask.number[0] = 34;
  expected_result.mask.number[0] = 3;
  CHECK_ROUND_OK

  a.mask.number[0] = 35;
  expected_result.mask.number[0] = 4;
  CHECK_ROUND_OK

  a.mask.sign = 1;
  expected_result.mask.sign = 1;
  CHECK_ROUND_OK

  a.mask.number[0] = 344455;
  a.mask.scale = 4;
  expected_result.mask.number[0] = 34;
  CHECK_ROUND_OK

  a.mask.number[0] = UINT32_MAX;
  a.mask.number[1] = UINT32_MAX;
  a.mask.number[2] = UINT32_MAX;
  a.mask.scale = 28;
  expected_result.mask.number[0] = 8;
  CHECK_ROUND_OK

  a.mask.scale = 27;
  expected_result.mask.number[0] = 79;
  CHECK_ROUND_OK

  a.mask.scale = 26;
  expected_result.mask.number[0] = 792;
  CHECK_ROUND_OK

  a.mask.scale = 25;
  expected_result.mask.number[0] = 7923;
  CHECK_ROUND_OK

  a.mask.scale = 24;
  expected_result.mask.number[0] = 79228;
  CHECK_ROUND_OK

  a.mask.scale = 23;
  expected_result.mask.number[0] = 792282;
  CHECK_ROUND_OK

  a.mask.scale = 22;
  expected_result.mask.number[0] = 7922816;
  CHECK_ROUND_OK

  a.mask.scale = 21;
  expected_result.mask.number[0] = 79228163;
  CHECK_ROUND_OK

  a.mask.scale = 20;
  expected_result.mask.number[0] = 792281625;
  CHECK_ROUND_OK

  s21_init_decimal(&a.orig);
  s21_init_decimal(&expected_result.orig);

  a.mask.sign = 1;
  a.mask.scale = 1;
  a.mask.number[0] = 1;
  expected_result.mask.sign = 1;
  CHECK_ROUND_OK
}
END_TEST

int tabathae_test(void) {
  Suite *s1 = suite_create("s21_sub");
  TCase *tc1_1 = tcase_create("s21_sub_tabathae");
  Suite *s2 = suite_create("s21_is_greater");
  TCase *tc2_1 = tcase_create("s21_is_greater_tabathae");
  Suite *s3 = suite_create("s21_is_greater_or_equal");
  TCase *tc3_1 = tcase_create("s21_is_greater_or_equal_tabathae");
  Suite *s4 = suite_create("s21_from_int_to_decimal");
  TCase *tc4_1 = tcase_create("s21_from_int_to_decimal_tabathae");
  Suite *s5 = suite_create("s21_round");
  TCase *tc5_1 = tcase_create("s21_round_tabathae");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, s21_sub_simple_zero_scale);
  tcase_add_test(tc1_1, s21_sub_harder_zero_scale);
  tcase_add_test(tc1_1, s21_sub_diff_scales);
  tcase_add_test(tc1_1, s21_sub_overflow);
  tcase_add_test(tc1_1, s21_sub_rounding);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, s21_is_greater_simple);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, s21_is_greater_or_equal_simple);
  suite_add_tcase(s4, tc4_1);
  tcase_add_test(tc4_1, s21_from_int_to_decimal_full);
  suite_add_tcase(s5, tc5_1);
  tcase_add_test(tc5_1, s21_round_simple);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);
  srunner_add_suite(sr, s4);
  srunner_add_suite(sr, s5);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
