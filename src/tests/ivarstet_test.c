/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "ivarstet_test.check" instead.
 */

#include <check.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "../s21_decimal.h"

START_TEST(add_two_pos) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{0}, {0}, {0}},
      {{{0x18894, 0x0, 0x0, 0x0}},
       {{0x64, 0x0, 0x0, 0x0}},
       {{0x188F8, 0x0, 0x0, 0x0}}},
      {{{0xB835552A, 0x425, 0x0, 0x0}},
       {{0x22E8650A, 0xF, 0x0, 0x0}},
       {{0xDB1DBA34, 0x434, 0x0, 0x0}}},
      {{{0x9F347AC3, 0x38D00603, 0xBBEEB, 0x0}},
       {{0x72122795, 0x89186481, 0x0, 0x0}},
       {{0x1146A258, 0xC1E86A85, 0xBBEEB, 0x0}}},
      {{{0xFFFFFFFF, 0, 0, 0x0}},
       {{0xFFFFFFFF, 0x0, 0x0, 0x0}},
       {{0xFFFFFFFE, 0x1, 0, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x0}},
       {{0x1, 0x0, 0x0, 0x0}},
       {{0x0, 0x0, 0xFFFFFFFF, 0x0}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

START_TEST(add_one_neg) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{{0x3F6C97, 0x0, 0x0, 0x80000000}},
       {{0x345, 0x0, 0x0, 0x0}},
       {{0x3F6952, 0x0, 0x0, 0x80000000}}},
      {{{0xB12001F5, 0xA, 0x0, 0x0}},
       {{0x2F64F20A, 0x0, 0x0, 0x80000000}},
       {{0x81BB0FEB, 0xA, 0x0, 0x0}}},
      {{{0x43A73CA6, 0x9BF67292, 0x193, 0x80000000}},
       {{0xFD356E21, 0x31D21C81, 0x28, 0x0}},
       {{0x4671CE85, 0x6A245610, 0x16B, 0x80000000}}},
      {{{0x37EC3B64, 0x83741486, 0x4A45BD, 0x0}},
       {{0x5AF0C9AC, 0x9E786641, 0x3C04B, 0x80000000}},
       {{0xDCFB71B8, 0xE4FBAE44, 0x468571, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0}},
       {{0xE4C933C, 0x1, 0x0, 0x80000000}},
       {{0xF1B36CC3, 0xFFFFFFFE, 0xFFFFFFFF, 0x0}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

START_TEST(add_two_neg) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{{0x26168, 0x0, 0x0, 0x80000000}},
       {{0xE7748, 0x0, 0x0, 0x80000000}},
       {{0x10D8B0, 0x0, 0x0, 0x80000000}}},
      {{{0xAA128D9, 0x2E079, 0x0, 0x80000000}},
       {{0xEE636E92, 0x7F, 0x0, 0x80000000}},
       {{0xF904976B, 0x2E0F8, 0x0, 0x80000000}}},
      {{{0xD318C28D, 0xB7B21664, 0x15, 0x80000000}},
       {{0x5A344DCE, 0x19BF73A5, 0x5, 0x80000000}},
       {{0x2D4D105B, 0xD1718A0A, 0x1A, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x80000000}},
       {{0x1, 0x0, 0x0, 0x80000000}},
       {{0x0, 0x0, 0xFFFFFFFF, 0x80000000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

START_TEST(add_two_pos_sc) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{{0x1, 0x1, 0x1, 0x10000}},
       {{0x1, 0x1, 0x1, 0x10000}},
       {{0x2, 0x2, 0x2, 0x10000}}},
      {{{0x1, 0x1, 0x1, 0x10000}},
       {{0x1, 0x1, 0x1, 0xA0000}},
       {{0x3B9ACA01, 0x3B9ACA01, 0x3B9ACA01, 0xA0000}}},

      {{{0x1, 0x0, 0x0, 0x1C0000}},
       {{0x1, 0x0, 0x0, 0x1C0000}},
       {{0x2, 0x0, 0x0, 0x1C0000}}},
      {{{0x1, 0x0, 0x0, 0x1C0000}},
       {{0x1, 0x0, 0x0, 0x10000}},
       {{0xE8000001, 0x9FD0803C, 0x33B2E3C, 0x1C0000}}},
      {{{0x1, 0x0, 0x0, 0x1C0000}},
       {{0xA, 0x0, 0x0, 0x0}},
       {{0x10000000, 0x3E250261, 0x204FCE5E, 0x1B0000}}},
      {{{0x1, 0x0, 0x0, 0x1C0000}},
       {{0x23F6BD, 0x0, 0x0, 0x0}},
       {{0x19400000, 0xB154B4DF, 0x4C2806D2, 0x160000}}},
      {{{0x9E64028, 0x0, 0x0, 0xD0000}},
       {{0x23F6BD, 0x0, 0x0, 0x30000}},
       {{0xAFC59428, 0x53BC1B, 0x0, 0xD0000}}},
      {{{0x20C9A822, 0x86673CED, 0xB7592DBF, 0x0}},
       {{0x11E1A300, 0x0, 0x0, 0x90000}},
       {{0x20C9A822, 0x86673CED, 0xB7592DBF, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x10000}},
       {{0x5, 0x0, 0x0, 0x10000}},
       {{0x9999999A, 0x99999999, 0x19999999, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0}},
       {{0x4, 0x0, 0x0, 0x10000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x10000}},
       {{0x999999A1, 0x99999999, 0x19999999, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x33333333, 0x33333333, 0x33333333, 0x1B0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

START_TEST(add_one_neg_sc) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{{0x18, 0x1, 0x1, 0x80010000}},
       {{0x1, 0xF, 0x1, 0xA0000}},
       {{0x9682EFFF, 0x3B9AC9F6, 0x3B9AC9FF, 0x800A0000}}},
      {{{0x1, 0x1, 0x1, 0xA0000}},
       {{0x1, 0x1, 0x1, 0x80010000}},
       {{0x3B9AC9FF, 0x3B9AC9FF, 0x3B9AC9FF, 0x800A0000}}},

      {{{0x0, 0x0, 0x0, 0xD0000}},
       {{0x1, 0x0, 0x0, 0x801C0000}},
       {{0x1, 0x0, 0x0, 0x801C0000}}},
      {{{0x6F711, 0x0, 0x0, 0x800D0000}},
       {{0x77B75C, 0x0, 0x0, 0xA0000}},
       {{0xD39D484F, 0x1, 0x0, 0xD0000}}},
      {{{0xACE87759, 0x103B44, 0x0, 0xD0000}},
       {{0xB7A1E5F, 0x29318DE2, 0x22D, 0xA0000}},
       {{0x81EF1A71, 0xE9A27641, 0x88068, 0xD0000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x120000}},
       {{0xA1091520, 0x920C8098, 0xFFFFFFFF, 0x120000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x0, 0x0, 0x0, 0x1C0000}}},  // 0x801C0000
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x0, 0x0, 0x0, 0x1C0000}}},  // 0x801C0000
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j) {
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
    }
  }
}
END_TEST

START_TEST(add_two_neg_sc) {
  struct testcase {
    s21_decimal a1, a2, expected;
  };

  struct testcase testcases[] = {
      {{{0x1, 0x0, 0x0, 0x801C0000}},
       {{0x1, 0x0, 0x0, 0x80010000}},
       {{0xE8000001, 0x9FD0803C, 0x33B2E3C, 0x801C0000}}},
      {{{0x94C86B6, 0x0, 0x0, 0x80090000}},
       {{0x6068B050, 0x2D, 0x0, 0x80000000}},
       {{0x248BA6B6, 0x90A7EDAF, 0xA, 0x80090000}}},
      {{{0xEE662A0B, 0x1D55A, 0x0, 0x80000000}},
       {{0xFBFA9920, 0xC77C723, 0x0, 0x80000000}},
       {{0xEA60C32B, 0xC799C7E, 0x0, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0x33333333, 0x33333333, 0x33333333, 0x801B0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

START_TEST(add_too_big) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{0x1, 0, 0, 0}}, {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0}}, {{0x5, 0x0, 0x0, 0x10000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x10000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(add_too_small) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{0x1, 0, 0, 0x80000000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}},
       {{0x5, 0x0, 0x0, 0x80010000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80010000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_add(testcases[i].a1, testcases[i].a2, &actual);
    ck_assert_int_eq(2, result);
  }
}
END_TEST

START_TEST(is_less_no_scale_true) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{0}, {{1, 0, 0, 0}}},
      {{{1, 0, 0, 0x80000000}}, {{1, 0, 0, 0}}},
      {{{~0, ~0, ~0, 0x80000000}}, {0}},
      {{{~0, ~0, ~0, 0x80000000}}, {{~0, ~0, ~0, 0}}},
      {{{~0, ~0, ~0, 0x80000000}}, {{~0, ~0, ~0, 0}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(is_less_no_scale_false) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{1, 0, 0, 0}}, {0}},
      {{{1, 0, 0, 0}}, {{1, 0, 0, 0x80000000}}},
      {{0}, {{~0, ~0, ~0, 0x80000000}}},
      {{{~0, ~0, ~0, 0}}, {{~0, ~0, ~0, 0x80000000}}},
      {{{~0, ~0, ~0, 0}}, {{~0, ~0, ~0, 0x80000000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(0, result);
  }
}
END_TEST

START_TEST(is_less_scale_true) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{0}, {{1, 0, 0, 0x1C0000}}},
      {{{1, 0, 0, 0x80000000}}, {{1, 0, 0, 0x1C0000}}},
      {{{~0, ~0, ~0, 0x801C0000}}, {0}},
      {{{~0, ~0, ~0, 0x801C0000}}, {{~0, ~0, ~0, 0x1C0000}}},
      {{{~0, ~0, ~0, 0x801C0000}}, {{~0, ~0, ~0, 0x1C0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(is_less_scale_false) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{1, 0, 0, 0x1C0000}}, {0}},
      {{{1, 0, 0, 0x1C0000}}, {{1, 0, 0, 0x80000000}}},
      {{0}, {{~0, ~0, ~0, 0x801C0000}}},
      {{{~0, ~0, ~0, 0x1C0000}}, {{~0, ~0, ~0, 0x801C0000}}},
      {{{~0, ~0, ~0, 0x1C0000}}, {{~0, ~0, ~0, 0x801C0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(0, result);
  }
}
END_TEST

START_TEST(is_less_se_true) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{0x28000000, 0x9E548224, 0x1D14A021, 0x1B0000}},
       {{0xA, 0x0, 0x0, 0x0}}},
      {{{0x28000000, 0x9E548224, 0x1D14A021, 0x801B0000}},
       {{0x8, 0x0, 0x0, 0x80000000}}},
      {{{0xA14F6064, 0x205CA38E, 0x10BF, 0x80160000}},
       {{0x85387EFC, 0x18F58B, 0x0, 0x800F0000}}},
      {{{0xCD100000, 0xB18BC59E, 0x1AC, 0x80150000}},
       {{0xCA230000, 0x7730B877, 0xEE0, 0x80160000}}},
      {{{~0, ~0, ~0, 0x801C0000}}, {{0x85387EFC, 0x18F58B, 0x0, 0x800F0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(is_less_se_false) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{0, 0, 0, 0x801C0000}}, {0}},
      {{{0, 0, 0, 0x1C0000}}, {0}},
      {{{0xF6800000, 0x2C7E14A, 0x152D, 0x150000}}, {{0xA, 0x0, 0x0, 0x0}}},
      {{{0xF6800000, 0x2C7E14A, 0x152D, 0x150000}}, {{0x64, 0x0, 0x0, 0x0}}},
      {{{0x68BC2718, 0xE5B1E724, 0x9, 0x70000}},
       {{0x40541800, 0x480AE8E2, 0x3AFDFFA7, 0xF0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(0, result);
  }
}
END_TEST

START_TEST(is_loe_se_true) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{0, 0, 0, 0x801C0000}}, {0}},
      {{{0, 0, 0, 0x1C0000}}, {0}},
      {{{0xF6800000, 0x2C7E14A, 0x152D, 0x150000}}, {{0x64, 0x0, 0x0, 0x0}}},
      {{{0x68BC2718, 0xE5B1E724, 0x9, 0x70000}},
       {{0x40541800, 0x480AE8E2, 0x3AFDFFA7, 0xF0000}}},
      {{{0x28000000, 0x9E548224, 0x1D14A021, 0x1B0000}},
       {{0xA, 0x0, 0x0, 0x0}}},
      {{{0x28000000, 0x9E548224, 0x1D14A021, 0x801B0000}},
       {{0x8, 0x0, 0x0, 0x80000000}}},
      {{{0xA14F6064, 0x205CA38E, 0x10BF, 0x80160000}},
       {{0x85387EFC, 0x18F58B, 0x0, 0x800F0000}}},
      {{{0xCD100000, 0xB18BC59E, 0x1AC, 0x80150000}},
       {{0xCA230000, 0x7730B877, 0xEE0, 0x80160000}}},
      {{{~0, ~0, ~0, 0x801C0000}}, {{0x85387EFC, 0x18F58B, 0x0, 0x800F0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less_or_equal(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(is_loe_se_false) {
  struct testcase {
    s21_decimal a1, a2;
  };

  struct testcase testcases[] = {
      {{{1, 0, 0, 0}}, {0}},
      {{{1, 0, 0, 0}}, {{1, 0, 0, 0x80000000}}},
      {{{1, 0, 0, 0x1C0000}}, {0}},
      {{{1, 0, 0, 0x1C0000}}, {{1, 0, 0, 0x80000000}}},
      {{{0xF6800000, 0x2C7E14A, 0x152D, 0x150000}}, {{0xA, 0x0, 0x0, 0x0}}},
      {{0}, {{~0, ~0, ~0, 0x80000000}}},
      {{{~0, ~0, ~0, 0}}, {{~0, ~0, ~0, 0x80000000}}},
      {{{~0, ~0, ~0, 0}}, {{~0, ~0, ~0, 0x80000000}}},
      {{0}, {{~0, ~0, ~0, 0x801C0000}}},
      {{{~0, ~0, ~0, 0x1C0000}}, {{~0, ~0, ~0, 0x801C0000}}},
      {{{~0, ~0, ~0, 0x1C0000}}, {{~0, ~0, ~0, 0x801C0000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    int result = s21_is_less_or_equal(testcases[i].a1, testcases[i].a2);
    ck_assert_int_eq(0, result);
  }
}
END_TEST

START_TEST(test_f2d) {
  struct testcase {
    float f;
    s21_decimal expected;
  };

  struct testcase testcases[] = {
      {0., {0}},
      {1., {0x1, 0x0, 0x0, 0x0}},
      {-1., {0x1, 0x0, 0x0, 0x80000000}},
      {0.0000003460946235002642, {0x34CF52, 0x0, 0x0, 0xD0000}},
      {123.45, {0x3039, 0x0, 0x0, 0x20000}},
      {1E-28, {0x1, 0x0, 0x0, 0x1C0000}},
      {350235.02636230, {0x5581B, 0x0, 0x0, 0x0}},
      {6.532895E-06, {0x63AF1F, 0x0, 0x0, 0xC0000}},
      {3.8562E-16, {0x96A2, 0x0, 0x0, 0x140000}},
      {387436e-32F, {0x27, 0x0, 0x0, 0x1C0000}},
      {-12486.980867, {0x130DBA, 0x0, 0x0, 0x80020000}},
      {-51391093760930125.0191806801, {0x9011F400, 0xB693EC, 0x0, 0x80000000}},
      {1501757923705102302366236.10032688204,
       {0xF2380000, 0x76DCD91B, 0x13E02, 0x0}},
      {10050175792037051023023606236.010032688204,
       {0xA800000, 0x7E5737EB, 0x20795065, 0x0}},
      {7.922816E+27, {0xD0000000, 0xF85B7835, 0x1999998B, 0x0}},
      {-7.922816E+27, {0xD0000000, 0xF85B7835, 0x1999998B, 0x80000000}},
      {4.95176E+26, {0x5D000000, 0xBF85B783, 0x1999998, 0x0}},
      {-4.95176E+26, {0x5D000000, 0xBF85B783, 0x1999998, 0x80000000}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_from_float_to_decimal(testcases[i].f, &actual);
    ck_assert_int_eq(0, result);

    if (!s21_is_equal(actual, testcases[i].expected)) {
      fprintf(stderr, "failed s21_f2d test N%zu\n", i);
      break;
    }
  }
}
END_TEST

START_TEST(test_f2d_err) {
  struct testcase {
    float f;
  };

  struct testcase testcases[] = {
      {(0. / 0.)},
      {(1. / 0.)},
      {1e-32},
      {72638578e32},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_from_float_to_decimal(testcases[i].f, &actual);
    ck_assert_int_eq(1, result);
  }
}
END_TEST

START_TEST(test_s21_floor) {
  struct testcase {
    s21_decimal a1, expected;
  };

  struct testcase testcases[] = {
      {{0}, {0}},
      {{{0x1, 0x0, 0x0, 0x10000}}, {0}},
      {{{0x64, 0x0, 0x0, 0x1C0000}}, {0}},
      {{{0xFE5ACB9E, 0x67FF5DE2, 0xA5658, 0x140000}},
       {{0x1E82A, 0x0, 0x0, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x10000}},
       {{0x99999999, 0x99999999, 0x19999999, 0x0}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x7, 0x0, 0x0, 0x0}}},
      {{{0x5886B7EA, 0xA8177593, 0x4DA8298, 0x801B0000}},
       {{0x2, 0x0, 0x0, 0x80000000}}},
      {{{0x39BBEFAA, 0x1151702B, 0x0, 0x801B0000}},
       {{0x1, 0x0, 0x0, 0x80000000}}},
      {{{0x472FE5E9, 0x20B4787, 0x0, 0x80050000}},
       {{0xEFB76FF2, 0x156, 0x0, 0x80000000}}},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x801C0000}},
       {{0x8, 0x0, 0x0, 0x80000000}}},
      {{{0x65F3FC4F, 0xF9CAC02E, 0x1B, 0x80180000}},
       {{0x1, 0x0, 0x0, 0x80000000}}},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    s21_decimal actual = {0};
    int result = s21_floor(testcases[i].a1, &actual);
    ck_assert_int_eq(0, result);

    for (size_t j = 0; j < SIZE_BITS; ++j)
      ck_assert_int_eq(actual.bits[j], testcases[i].expected.bits[j]);
  }
}
END_TEST

int ivarstet_test(void) {
  Suite *s1 = suite_create("test_s21_add");
  TCase *tc1_1 = tcase_create("add_no_scale");
  TCase *tc1_2 = tcase_create("add_scale");
  TCase *tc1_3 = tcase_create("add_errors");
  Suite *s2 = suite_create("test_s21_is_less");
  TCase *tc2_1 = tcase_create("is_less_no_scale");
  TCase *tc2_2 = tcase_create("is_less_scale");
  TCase *tc2_3 = tcase_create("is_less_scale_extra");
  Suite *s3 = suite_create("test_s21_is_less_or_equal");
  TCase *tc3_1 = tcase_create("is_loe");
  Suite *s4 = suite_create("test_s21_from_float_to_decimal");
  TCase *tc4_1 = tcase_create("test_f2d");
  Suite *s5 = suite_create("test_s21_floor");
  TCase *tc5_1 = tcase_create("test_s21_floor");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, add_two_pos);
  tcase_add_test(tc1_1, add_one_neg);
  tcase_add_test(tc1_1, add_two_neg);
  suite_add_tcase(s1, tc1_2);
  tcase_add_test(tc1_2, add_two_pos_sc);
  tcase_add_test(tc1_2, add_one_neg_sc);
  tcase_add_test(tc1_2, add_two_neg_sc);
  suite_add_tcase(s1, tc1_3);
  tcase_add_test(tc1_3, add_too_big);
  tcase_add_test(tc1_3, add_too_small);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, is_less_no_scale_true);
  tcase_add_test(tc2_1, is_less_no_scale_false);
  suite_add_tcase(s2, tc2_2);
  tcase_add_test(tc2_2, is_less_scale_true);
  tcase_add_test(tc2_2, is_less_scale_false);
  suite_add_tcase(s2, tc2_3);
  tcase_add_test(tc2_3, is_less_se_true);
  tcase_add_test(tc2_3, is_less_se_false);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, is_loe_se_true);
  tcase_add_test(tc3_1, is_loe_se_false);
  suite_add_tcase(s4, tc4_1);
  tcase_add_test(tc4_1, test_f2d);
  tcase_add_test(tc4_1, test_f2d_err);
  suite_add_tcase(s5, tc5_1);
  tcase_add_test(tc5_1, test_s21_floor);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);
  srunner_add_suite(sr, s4);
  srunner_add_suite(sr, s5);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
