/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "tests/wilmerno_test.check" instead.
 */

#include <check.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>

#include "../s21_decimal.h"

#define SET_MINUS(x) ((x) | 0x80000000)

#define SET_SCALE(x, y) ((x) | ((y) << 16))

enum {
  SUCCESS = 0,
  CONVERTION_ERROR = 1,
  TOO_BIG = 1,
  TOO_SMALL = 2,
  DIV_BY_ZERO = 3,
};

START_TEST(positive_tests) {
  struct testcase {
    s21_decimal value;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {
          {{0}},
          {{0, 0, 0, SET_MINUS(0)}},
          SUCCESS,
      },
      {{{0, 0, 0, SET_MINUS(0)}}, {{0}}, SUCCESS},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       {{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}},
       SUCCESS},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}},
       {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       SUCCESS},
      {{{1, 0, 0, SET_SCALE(0, 28)}},
       {{1, 0, 0, SET_MINUS(SET_SCALE(0, 28))}},
       SUCCESS},
      {{{1, 0, 0, SET_MINUS(SET_SCALE(0, 28))}},
       {{1, 0, 0, SET_SCALE(0, 28)}},
       SUCCESS},
      {{{434, 4356456, 34524, 0}},
       {{434, 4356456, 34524, SET_MINUS(0)}},
       SUCCESS},
      {{{845345432, 6556, 3245, SET_MINUS(0)}},
       {{845345432, 6556, 3245, 0}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_negate(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(equivalent_without_scale_not) {
  struct testcase {
    s21_decimal first, second;
  };

  struct testcase testcases[] = {
      {{{0}}, {{0}}},
      {{{1, 0, 0, 0}}, {{1, 0, 0, 0}}},
      {{{0, 0, 0, SET_MINUS(0)}}, {{0}}},
      {{{1, 0, 0, SET_MINUS(0)}}, {{1, 0, 0, SET_MINUS(0)}}},
      {{{123, 456, 789, 0}}, {{123, 456, 789, 0}}},
      {{{INT_MAX, INT_MAX, INT_MAX, 0}}, {{INT_MAX, INT_MAX, INT_MAX, 0}}},
      {{{INT_MAX, INT_MAX, INT_MAX, SET_MINUS(0)}},
       {{INT_MAX, INT_MAX, INT_MAX, SET_MINUS(0)}}}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    ck_assert_int_eq(s21_is_not_equal(testcases[i].first, testcases[i].second),
                     0);
  }
}
END_TEST

START_TEST(equivalent_with_scale_not) {
  struct testcase {
    s21_decimal first, second;
  };

  struct testcase testcases[] = {
      {{{0, 0, 0, 0}}, {{0, 0, 0, SET_SCALE(0, 28)}}},
      {{{10000, 0, 0, SET_SCALE(0, 4)}}, {{1000000, 0, 0, SET_SCALE(0, 6)}}},
      {{{0, 0, 0, SET_MINUS(SET_SCALE(0, 14))}}, {{0, 0, 0, SET_SCALE(0, 20)}}},
      {{{123, 456, 789, SET_SCALE(0, 12)}},
       {{123, 456, 789, SET_SCALE(0, 12)}}},
      {{{1832294, 1238547, 2500000, SET_MINUS(SET_SCALE(0, 19))}},
       {{1832294, 1238547, 2500000, SET_MINUS(SET_SCALE(0, 19))}}},
      {{{~0, ~0, ~0, SET_SCALE(0, 1)}}, {{~0, ~0, ~0, SET_SCALE(0, 1)}}},
      {{{705032704, 1, 0, SET_SCALE(0, 9)}}, {{50, 0, 0, SET_SCALE(0, 1)}}}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    ck_assert_int_eq(s21_is_not_equal(testcases[i].first, testcases[i].second),
                     0);
  }
}
END_TEST

START_TEST(different_without_scale_not) {
  struct testcase {
    s21_decimal first, second;
  };

  struct testcase testcases[] = {
      {{{1, 1, 0, 0}}, {{0, 0, 1, 0}}},
      {{{255, 255, 255, 0}}, {{255, 255, 255, SET_MINUS(0)}}},
      {{{~1, ~0, ~0, 0}}, {{~0, ~0, ~0, 0}}},
      {{{~0, ~1, 293, SET_MINUS(0)}}, {{~0, ~0, 293, SET_MINUS(0)}}},
      {{{~0, ~0, ~0, 0}}, {{~0, ~0, ~0, SET_MINUS(0)}}},
      {{{234, 8913250, 2831049, 0}}, {{141241, 4564363, 13919857}}}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    ck_assert_int_eq(s21_is_not_equal(testcases[i].first, testcases[i].second),
                     1);
  }
}
END_TEST

START_TEST(different_with_scale_not) {
  struct testcase {
    s21_decimal first, second;
  };

  struct testcase testcases[] = {
      {{{1, 0, 0, SET_SCALE(0, 14)}}, {{1, 0, 0, SET_SCALE(0, 28)}}},
      {{{234, 8391245, 2000000000, SET_SCALE(0, 3)}},
       {{234, 8391245, 2000000000, SET_MINUS(SET_SCALE(0, 3))}}},
      {{{0, 0, 2, SET_SCALE(0, 23)}}, {{2, 0, 0, SET_SCALE(0, 13)}}},
      {{{73812940, 1238594, ~23, SET_SCALE(0, 18)}},
       {{14895304, 4732995, ~933, SET_MINUS(SET_SCALE(0, 11))}}},
      {{{~0, ~0, ~0, SET_SCALE(0, 28)}}, {{~1, ~0, ~0, SET_SCALE(0, 28)}}},
      {{{~0, ~1, ~2, SET_SCALE(0, 27)}}, {{~2, ~2, ~3, SET_SCALE(0, 28)}}}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; ++i) {
    ck_assert_int_eq(s21_is_not_equal(testcases[i].first, testcases[i].second),
                     1);
  }
}
END_TEST

START_TEST(integer_without_scale) {
  struct testcase {
    s21_decimal value;
    int expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x7FFFFFFF, 0x0, 0x0, 0x0}}, 2147483647, SUCCESS},
      {{{0x80000000, 0x0, 0x0, SET_MINUS(0)}}, -2147483648, SUCCESS},
      {{{0, 0, 0, 0}}, 0, SUCCESS},
      {{{0, 0, 0, SET_MINUS(0)}}, 0, SUCCESS},
      {{{0x52E416, 0x0, 0x0, 0x0}}, 5432342, SUCCESS},
      {{{0x2074E776, 0x0, 0x0, SET_MINUS(0)}}, -544532342, SUCCESS}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(result, testcases[i].expected);
  }
}
END_TEST

START_TEST(integer_with_scale) {
  struct testcase {
    s21_decimal value;
    int expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0xD0D04980, 0x1EF3F, 0x0, SET_MINUS(SET_SCALE(0, 6))}},
       -544532342,
       SUCCESS},
      {{{0x36B83A8, 0x1, 0x0, SET_SCALE(0, 3)}}, 4352345, SUCCESS},
      {{{0, 0, 0, SET_SCALE(0, 23)}}, 0, SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(result, testcases[i].expected);
  }
}
END_TEST

START_TEST(normal_fractional) {
  struct testcase {
    s21_decimal value;
    int expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x39E5EBF, 0x1, 0x0, 0x70000}}, 435, SUCCESS},
      {{{0x1F33471A, 0x0, 0x0, 0x80010000}}, -52345423, SUCCESS},
      {{{0x8015A, 0x0, 0x0, 0x60000}}, 0, SUCCESS},
      {{{0xD50F, 0x0, 0x0, 0x80060000}}, 0, SUCCESS}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(result, testcases[i].expected);
  }
}
END_TEST

START_TEST(big_integer_without_scale) {
  struct testcase {
    s21_decimal value;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x80000000, 0, 0, 0}}, CONVERTION_ERROR},
      {{{0x80000001, 0, 0, SET_MINUS(0)}}, CONVERTION_ERROR},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}}, CONVERTION_ERROR},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}}, CONVERTION_ERROR},
      {{{0xFDBA5930, 0x2FCF443D, 0x11C37A, 0}}, CONVERTION_ERROR},
      {{{0x124E26B3, 0xA, 0, SET_MINUS(0)}}, CONVERTION_ERROR},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

START_TEST(big_integer_with_scale) {
  struct testcase {
    s21_decimal value;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x0, 0xA43B7400, 0xB, SET_SCALE(0, 11)}}, CONVERTION_ERROR},
      {{{0x4876E800, 0xA43B7417, 0xB, SET_MINUS(SET_SCALE(0, 11))}},
       CONVERTION_ERROR},
      {{{0xD6115500, 0x10F9DFB, 0, SET_MINUS(SET_SCALE(0, 5))}},
       CONVERTION_ERROR},
      {{{0x93D3E840, 0x20149, 0, SET_SCALE(0, 5)}}, CONVERTION_ERROR},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

START_TEST(big_fractional) {
  struct testcase {
    s21_decimal value;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x706342, 0x4C4B40, 0, 0x70000}}, CONVERTION_ERROR},
      {{{0x411A5BCC, 0x6A528981, 0x74, 0x800C0000}}, CONVERTION_ERROR},
      {{{0xCEECD028, 0x5826E743, 0xA96D6AB8, 0x100000}}, CONVERTION_ERROR},
      {{{0xDC84829A, 0x107D0CA, 0, 0x80040000}}, CONVERTION_ERROR},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    int result = 0;
    int err = s21_from_decimal_to_int(testcases[i].value, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

START_TEST(integer_div) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0}}, {{0xEB, 0x0, 0x0, 0x0}}, {{0}}, SUCCESS},
      {{{0x16, 0x0, 0x0, 0x0}},
       {{0x16, 0x0, 0x0, 0x0}},
       {{0x1, 0x0, 0x0, 0x0}},
       SUCCESS},
      {{{0x1, 0x0, 0x0, 0x0}},
       {{0x17A9F356, 0x112FD990, 0x3, 0x0}},
       {{0xA88EA3E, 0x0, 0x0, 0x1C0000}},
       SUCCESS},
      {{{0xDD2E722A, 0x478EC4B1, 0x0, 0x80000000}},
       {{0x67C9B765, 0x1B2E9F, 0x0, 0x0}},
       {{0xEFD16BB9, 0x74814D63, 0xD9C1F256, 0x801A0000}},
       SUCCESS},
      {{{0x662498C0, 0xF3C4D57A, 0x1B, 0x80000000}},
       {{0x6, 0x0, 0x0, 0x80000000}},
       {{0x4557555, 0xF2F5D74C, 0x1BC49E21, 0x80000}},
       SUCCESS},
      {{{0x1, 0x0, 0x0, 0x80000000}},
       {{0x3, 0x0, 0x0, 0x0}},
       {{0x5555555, 0x14B700CB, 0xAC544CA, 0x801C0000}},
       SUCCESS},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       {{1, 0, 0, 0}},
       {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       SUCCESS},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}},
       {{1, 0, 0, 0}},
       {{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_dividend_div) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x1B0, 0x0, 0x0, 0x80170000}},
       {{0x3037, 0x0, 0x0, 0x0}},
       {{0x23, 0x0, 0x0, 0x801A0000}},
       SUCCESS},
      {{{1, 0, 0, SET_SCALE(0, 28)}},
       {{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       {{0}},
       SUCCESS},
      {{{0x1, 0x0, 0x0, 0x150000}},
       {{0xA, 0x0, 0x0, 0x80000000}},
       {{0x1, 0x0, 0x0, 0x80160000}},
       SUCCESS},
      {{{0x9BE1E23E, 0xA15D0951, 0xA2, 0x150000}},
       {{0x578827, 0x0, 0x0, 0x0}},
       {{0xAEF571, 0x59A41A97, 0x1C, 0x1B0000}},
       SUCCESS},
      {{{0xDF1462B7, 0x19F66722, 0xFCDA7FD1, 0xF0000}},
       {{0xE3E18ECF, 0x35, 0x0, 0x0}},
       {{0xBC4B8DCA, 0x5B22356F, 0x6D3E98BD, 0x1A0000}},
       SUCCESS},
      {{{0x33DB6BBF, 0xB383CB0D, 0xAE7BCCFE, 0xA0000}},
       {{0x302C, 0x0, 0x0, 0x0}},
       {{0xF9CE9353, 0xD90FF24A, 0x8D7D0D31, 0xE0000}},
       SUCCESS},
      {{{0xA66146AD, 0xBA4994, 0x0, 0x800A0000}},
       {{0x138605F6, 0x1BF3AF, 0x0, 0x0}},
       {{0xF9DAFD65, 0x5C7D5236, 0x0, 0x801C0000}},
       SUCCESS}};

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_divider_div) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x15, 0x0, 0x0, 0x80000000}},
       {{0x7224E, 0x0, 0x0, 0x150000}},
       {{0xDA0B279F, 0xE205286A, 0x912212F5, 0x800C0000}},
       SUCCESS},
      {{{0x4F154BC8, 0x46CA7, 0x0, 0x0}},
       {{0xA94FC756, 0x4FEC6035, 0x27E152AD, 0xB0000}},
       {{0xEA534A4, 0x86FD5DD5, 0x858AF, 0x1B0000}},
       SUCCESS},
      {{{0x4DD, 0x0, 0x0, 0x0}},
       {{0x97355323, 0xF0991BE, 0x3, 0x800A0000}},
       {{0xCC7319F9, 0x9D8FE991, 0x77, 0x801C0000}},
       SUCCESS},
      {{{0x1, 0x0, 0x0, 0x0}},
       {{0xCE9940A7, 0x44A1, 0x0, 0x10000}},
       {{0x4954A65E, 0x4B53D, 0x0, 0x1C0000}},
       SUCCESS},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x80000000}},
       {{0x4E72A001, 0x918, 0x0, 0xD0000}},
       {{0x97B68C96, 0xFFE3DA3D, 0xFFFFFFFF, 0x80000000}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_div) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0xFC3A281D, 0xFF5AE408, 0x79D4980, 0xC0000}},
       {{0x8D2D98BA, 0xE86955F4, 0x1F30F, 0x170000}},
       {{0x606871F8, 0x10FD4DF0, 0x33B1B4C, 0xD0000}},
       SUCCESS},
      {{{0x8422E100, 0xAC471B47, 0xA7C5, 0x80050000}},
       {{0x4E72A002, 0x918, 0x0, 0xD0000}},
       {{0xe7ffbf5e, 0xffc7b47a, 0xFFFFFFFF, 0x800A0000}},
       SUCCESS},
      {{{0x2C60E57, 0x0, 0x0, 0xE0000}},
       {{0x5EA537E6, 0xA55563, 0x0, 0x90000}},
       {{0x27B2BA65, 0x918, 0x0, 0x1B0000}},
       SUCCESS},
      {{{0x65D60E57, 0x6BC75E2D, 0x5, 0x140000}},
       {{0x17C65BE6, 0x2A6AF0FB, 0x180F279, 0x90000}},
       {{0xCB4C4D, 0x5, 0x0, 0x1C0000}},
       SUCCESS},
      {{{0x2C60E57, 0x0, 0x0, 0x140000}},
       {{0x1B6, 0x0, 0x0, 0x170000}},
       {{0x200336F1, 0x9449BBCD, 0x22542D38, 0x140000}},
       SUCCESS},
      {{{0xEB4E4945, 0xB9082560, 0x1EFD6, 0xB0000}},
       {{0x9A3D614C, 0x734F46, 0x0, 0xF0000}},
       {{0x58ACA60, 0x3BC3EBE0, 0xE91B59E4, 0x110000}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(div_by_zero_div) {
  struct testcase {
    s21_decimal dividend, divider;
    int error;
  };

  struct testcase testcases[] = {
      {{{0xC591511, 0x23D033AF, 0x15E979A5, 0x80020000}}, {{0}}, DIV_BY_ZERO},
      {{{0x766F160, 0xE63667CE, 0x16F, 0x80130000}}, {{0}}, DIV_BY_ZERO},
      {{{0x5BE261A0, 0x268EC, 0x0, 0x70000}},
       {{0, 0, 0, SET_SCALE(0, 22)}},
       DIV_BY_ZERO},
      {{{0}}, {{0}}, DIV_BY_ZERO},
      {{{0xF3C3FB6E, 0x204081AF, 0x0, 0x1B0000}},
       {{0, 0, 0, SET_MINUS(SET_SCALE(0, 12))}},
       DIV_BY_ZERO},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

START_TEST(too_big_result) {
  struct testcase {
    s21_decimal dividend, divider;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x2352F8BF, 0xF2D9DF23, 0x2A, 0x0}},
       {{0x1, 0x0, 0x0, 0x130000}},
       TOO_BIG},
      {{{0x8C37DAAF, 0x1A99E96D, 0x4C24E569, 0x30000}},
       {{0xFF3D98BA, 0xF1E281B1, 0x2, 0x80180000}},
       TOO_SMALL},
      {{{0xC591511, 0x23D033AF, 0x15E979A5, 0x80020000}},
       {{0x61E76A5A, 0x3F1, 0x0, 0x100000}},
       TOO_SMALL},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, 0}},
       {{1, 0, 0, SET_SCALE(0, 28)}},
       TOO_BIG},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_div(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

START_TEST(integer_mod) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x21F, 0x0, 0x0, 0x0}},
       {{0x98E5AAEF, 0x25367, 0x0, 0x80000000}},
       {{0x21F, 0x0, 0x0, 0x0}},
       SUCCESS},
      {{{0x6EC18, 0x0, 0x0, 0x0}}, {{0x6EC18, 0x0, 0x0, 0x0}}, {{0}}, SUCCESS},
      {{{0x19922D46, 0xB0, 0x0, 0x80000000}},
       {{0x19922D46, 0xB0, 0x0, 0x80000000}},
       {{0}},
       SUCCESS},
      {{{0x12786, 0x0, 0x0, 0x80000000}},
       {{0x5, 0x0, 0x0, 0x80000000}},
       {{0x4, 0x0, 0x0, 0x80000000}},
       SUCCESS},
      {{{0x552D82E7, 0x44BB18E1, 0x528, 0x0}},
       {{0x77A29984, 0x5EC301CF, 0x42, 0x0}},
       {{0x741C1E1B, 0x3C41F67B, 0x3B, 0x0}},
       SUCCESS},
      {{{0x6A3E3997, 0x1C48C0A, 0x23, 0x0}},
       {{0x3, 0x0, 0x0, 0x0}},
       {{0x2, 0x0, 0x0, 0x0}},
       SUCCESS},
      {{{0x19F76278, 0x0, 0x0, SET_MINUS(SET_SCALE(0, 3))}},
       {{0x3D680000, 0x95FB3A7, 0x0, SET_SCALE(0, 12)}},
       {{0x6A5BB, 0x0, 0x0, 0x80000000}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_mod(testcases[i].dividend, testcases[i].divider, &result);

    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_dividend_mod) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0xCAE06C01, 0x26422339, 0x97CA1FA1, 0x130000}},
       {{0x4E53FC83, 0x3D5BB49, 0x0, 0x90000}},
       {{0x1, 0x0, 0x0, 0x130000}},
       SUCCESS},
      {{{0x1, 0x0, 0x0, 0x1C0000}},
       {{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x1, 0x0, 0x0, 0x1C0000}},
       SUCCESS},
      {{{0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x1C0000}},
       {{0x1, 0x0, 0x0, 0x1C0000}},
       {{0x0, 0x0, 0x0, 0x1C0000}},
       SUCCESS},
      {{{0x83F81, 0x0, 0x0, 0x70000}},
       {{0x2D, 0x0, 0x0, 0x0}},
       {{0x83F81, 0x0, 0x0, 0x70000}},
       SUCCESS},
      {{{0x2B3E213, 0x0, 0x0, 0x10000}},
       {{0x198E, 0x0, 0x0, 0x0}},
       {{0x1C17, 0x0, 0x0, 0x10000}},
       SUCCESS},
      {{{0xCB01C248, 0x48, 0x0, 0x90000}},
       {{0x7, 0x0, 0x0, 0x0}},
       {{0x14C6BA48, 0x1, 0x0, 0x90000}},
       SUCCESS},
      {{{0x396C149B, 0x3A9D2C9F, 0x8B3A, 0xE0000}},
       {{0xB7ED2D6, 0x0, 0x0, 0x0}},
       {{0x45D9149B, 0x3246A96E, 0x5F, 0xE0000}},
       SUCCESS},
      {{{0x7C6B2F96, 0x5F3114EB, 0x1C8, 0x800F0000}},
       {{0xD7F, 0x0, 0x0, 0x80000000}},
       {{0xEE452F96, 0x1E74BACF, 0x0, 0x800F0000}},
       SUCCESS},
      {{{0x1B0, 0x0, 0x0, 0x80030000}},
       {{0xD7F, 0x0, 0x0, 0x80000000}},
       {{0x1B0, 0x0, 0x0, 0x80030000}},
       SUCCESS},
      {{{0x155, 0x0, 0x0, 0xD0000}},
       {{0x2052F6B8, 0x2038, 0x0, 0x0}},
       {{0x155, 0x0, 0x0, 0xD0000}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_mod(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_divider_mod) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x70000000, 0xB30310A7, 0xE22EA493, 0x0}},
       {{0x1, 0x0, 0x0, 0x30000}},
       {{0x0, 0x0, 0x0, 0x30000}},
       SUCCESS},
      {{{0x70000000, 0xB30310A7, 0xE22EA493, 0x80000000}},
       {{0x1, 0x0, 0x0, 0x30000}},
       {{0x0, 0x0, 0x0, 0x80030000}},
       SUCCESS},
      {{{0xB4489CAE, 0xC, 0x0, 0x0}},
       {{0x33DB4E6, 0x0, 0x0, 0x50000}},
       {{0x2D95D54, 0x0, 0x0, 0x50000}},
       SUCCESS},
      {{{0xDFB2F91, 0x0, 0x0, 0x80000000}},
       {{0x7D4D9, 0x0, 0x0, 0x70000}},
       {{0x1958E, 0x0, 0x0, 0x80070000}},
       SUCCESS},
      {{{0x27A, 0x0, 0x0, 0x0}},
       {{0x3E3BBAC, 0x0, 0x0, 0x20000}},
       {{0x27A, 0x0, 0x0, 0x0}},
       SUCCESS},
      {{{0x0, 0x0, 0x0, 0x0}},
       {{0x22, 0x0, 0x0, 0x70000}},
       {{0x0, 0x0, 0x0, 0x0}},
       SUCCESS},
      {{{0x982D2DCD, 0xD71B6DC, 0x0, 0x0}},
       {{0x9, 0x0, 0x0, 0x80010000}},
       {{0x3, 0x0, 0x0, 0x10000}},
       SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_mod(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(fraction_mod) {
  struct testcase {
    s21_decimal dividend, divider;
    s21_decimal expected;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x1, 0x1, 0x1, 0x10000}},
       {{0x1, 0x1, 0x1, 0x80010000}},
       {{0x0, 0x0, 0x0, 0x10000}},
       SUCCESS},
      {{{0x1, 0x1, 0x1, 0x80010000}},
       {{0x1, 0x1, 0x1, 0x10000}},
       {{0x0, 0x0, 0x0, 0x80010000}},
       SUCCESS},
      {{{0x1, 0x1, 0x1, 0x80010000}},
       {{0x1, 0x1, 0x1, 0x800A0000}},
       {{0x0, 0x0, 0x0, 0x800A0000}},
       SUCCESS},
      {{{0x1, 0x1, 0x1, 0x800A0000}},
       {{0x1, 0x1, 0x1, 0x80010000}},
       {{0x1, 0x1, 0x1, 0x800A0000}},
       SUCCESS},
      {{{0x1, 0x2, 0x3, 0x80010000}},
       {{0x3, 0x2, 0x1, 0x800A0000}},
       {{0x2329B003, 0x1194D800, 0x0, 0x800A0000}},
       SUCCESS},
      {{{0x3, 0x2, 0x1, 0x800A0000}},
       {{0x1, 0x2, 0x3, 0x80010000}},
       {{0x3, 0x2, 0x1, 0x800A0000}},
       SUCCESS},
      {{{0x1, 0x2, 0x3, 0xA0000}},
       {{0x3, 0x2, 0x1, 0x800A0000}},
       {{0xFFFFFFFB, 0xFFFFFFFD, 0x0, 0xA0000}},
       SUCCESS},
      {{{0x3, 0x2, 0x1, 0x800A0000}},
       {{0x1, 0x2, 0x3, 0xA0000}},
       {{0x3, 0x2, 0x1, 0x800A0000}},
       SUCCESS},

      {{{0xA1DA, 0x0, 0x0, 0xC0000}},
       {{0x345B4B, 0x0, 0x0, 0x110000}},
       {{0x1CD5A3, 0x0, 0x0, 0x110000}},
       SUCCESS},
      {{{0xA1DA, 0x0, 0x0, 0xC0000}},
       {{0x7E9E, 0x0, 0x0, 0x80000}},
       {{0xA1DA, 0x0, 0x0, 0xC0000}},
       SUCCESS},
      {{{0x32E362BB, 0x41D, 0x0, 0x70000}},
       {{0x7C257B88, 0x36CDD, 0x0, 0xD0000}},
       {{0x3E6B47A8, 0x2AB34, 0x0, 0xD0000}},
       SUCCESS},
      {{{0x82075E6F, 0x76E57E51, 0x0, 0x800C0000}},
       {{0x845140B2, 0x4DAD27E0, 0x868E, 0x80130000}},
       {{0x24646454, 0x42853FCC, 0x6FAC, 0x80130000}},
       SUCCESS},
      {{{0x503038F8, 0x9, 0x0, 0x80050000}},
       {{0x4D2, 0x0, 0x0, 0x90000}},
       {{0x3D8, 0x0, 0x0, 0x80090000}},
       SUCCESS},
      // {{{0xDA84B2F3, 0xD5F2D0A9, 0x1B, 0x10000}},
      //  {{0x157, 0x0, 0x0, 0x160000}},
      //  {{0x0, 0x0, 0x0, 0x160000}},
      //  SUCCESS},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_mod(testcases[i].dividend, testcases[i].divider, &result);
    // printf("i: %d\n", i);
    // s21_print(testcases[i].dividend);
    // printf("%%\n");
    // s21_print(testcases[i].divider);
    // printf("expected:");
    // s21_print(testcases[i].expected);
    // printf("result:");
    // s21_print(result);

    ck_assert_int_eq(err, testcases[i].error);
    ck_assert_int_eq(1, s21_is_equal(result, testcases[i].expected));
  }
}
END_TEST

START_TEST(dib_by_zero_mod) {
  struct testcase {
    s21_decimal dividend, divider;
    int error;
  };

  struct testcase testcases[] = {
      {{{0x17, 0x0, 0x0, 0x0}}, {{0x0, 0x0, 0x0, 0xA0000}}, DIV_BY_ZERO},
      {{{0xA7425366, 0x29DE1, 0x0, 0x0}},
       {{0x0, 0x0, 0x0, 0xD0000}},
       DIV_BY_ZERO},
      {{{UINT32_MAX, UINT32_MAX, UINT32_MAX, SET_MINUS(0)}},
       {{0}},
       DIV_BY_ZERO},
      {{{1, 0, 0, SET_SCALE(0, 28)}}, {{0}}, DIV_BY_ZERO},
      {{{0}}, {{0}}, DIV_BY_ZERO},
      {{{0x4E6C004E, 0x46F6AF58, 0x3056E, 0xE0000}},
       {{0, 0, 0, SET_MINUS(0)}},
       DIV_BY_ZERO},
  };

  size_t n = sizeof(testcases) / sizeof(testcases[0]);

  for (size_t i = 0; i < n; i++) {
    s21_decimal result = {{0}};
    int err = s21_mod(testcases[i].dividend, testcases[i].divider, &result);
    ck_assert_int_eq(err, testcases[i].error);
  }
}
END_TEST

int wilmerno_test() {
  Suite *s1 = suite_create("test_s21_negate");
  TCase *tc1_1 = tcase_create("test_s21_negate");
  Suite *s2 = suite_create("test_s21_is_not_equal");
  TCase *tc2_1 = tcase_create("equivalent_values_not");
  TCase *tc2_2 = tcase_create("different_values_not");
  Suite *s3 = suite_create("s21_from_decimal_to_int");
  TCase *tc3_1 = tcase_create("positive_tests_from_decimal_to_int");
  TCase *tc3_2 = tcase_create("nagative_tests_from_decimal_to_int");
  Suite *s4 = suite_create("s21_div");
  TCase *tc4_1 = tcase_create("positive_tests_div");
  TCase *tc4_2 = tcase_create("negative_tests_div");
  Suite *s5 = suite_create("s21_mod");
  TCase *tc5_1 = tcase_create("positive_tests_mod");
  TCase *tc5_2 = tcase_create("negative_tests_mod");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);
  tcase_add_test(tc1_1, positive_tests);
  suite_add_tcase(s2, tc2_1);
  tcase_add_test(tc2_1, equivalent_without_scale_not);
  tcase_add_test(tc2_1, equivalent_with_scale_not);
  suite_add_tcase(s2, tc2_2);
  tcase_add_test(tc2_2, different_without_scale_not);
  tcase_add_test(tc2_2, different_with_scale_not);
  suite_add_tcase(s3, tc3_1);
  tcase_add_test(tc3_1, integer_without_scale);
  tcase_add_test(tc3_1, integer_with_scale);
  tcase_add_test(tc3_1, normal_fractional);
  suite_add_tcase(s3, tc3_2);
  tcase_add_test(tc3_2, big_integer_without_scale);
  tcase_add_test(tc3_2, big_integer_with_scale);
  tcase_add_test(tc3_2, big_fractional);
  suite_add_tcase(s4, tc4_1);
  tcase_add_test(tc4_1, integer_div);
  tcase_add_test(tc4_1, fraction_dividend_div);
  tcase_add_test(tc4_1, fraction_divider_div);
  tcase_add_test(tc4_1, fraction_div);
  suite_add_tcase(s4, tc4_2);
  tcase_add_test(tc4_2, div_by_zero_div);
  tcase_add_test(tc4_2, too_big_result);
  suite_add_tcase(s5, tc5_1);
  tcase_add_test(tc5_1, integer_mod);
  tcase_add_test(tc5_1, fraction_dividend_mod);
  tcase_add_test(tc5_1, fraction_divider_mod);
  tcase_add_test(tc5_1, fraction_mod);
  suite_add_tcase(s5, tc5_2);
  tcase_add_test(tc5_2, dib_by_zero_mod);

  srunner_add_suite(sr, s2);
  srunner_add_suite(sr, s3);
  srunner_add_suite(sr, s4);
  srunner_add_suite(sr, s5);

  srunner_run_all(sr, CK_VERBOSE);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
